#!/bin/bash

set -eu

diff=$(cat -)

new_base_commit=""
commit_message=""

while getopts "b:m:" opt; do
    case $opt in
        b)
            new_base_commit=$OPTARG
            ;;
        m)
            commit_message=$OPTARG
            ;;
        \?)
            exit 1
            ;;
    esac
done

shift $((OPTIND - 1))

original_branch=$1

if [ -z "$original_branch" ]; then
    >&2 echo "Error: original branch not provided"
    exit 1
fi

if [[ -z "$diff" && -z "$rebasing_commit" ]]; then
    echo "No difference between old and new doppelganger, no need to update original"
    exit 0
fi

current_branch=$(git symbolic-ref --short HEAD)

# We need to switch to original branch to make changes
# To do so in an automated way, we need to stash all files that would cause conflicts
# We will optionally use stash multiple times, so we need a counter
num_stash_entries=0

# For simplicity, stash all tracked modified files
if [ -n "$(git diff --name-only)" ]; then
    git stash --message "Tracked files"
    (( num_stash_entries += 1 ))
fi

# Also stash untracked files that would lead to conflict when switching to original
# We do not want to naively stash all untracked files as some of them might be too
# large to be stored as a git object, which would take a lot of time
untracked_files=$(git ls-files --others --exclude-standard)
original_tracked_files=$(git ls-tree -r --name-only $original_branch)
# Intersect the two set of files to find conflicting files
untracked_conflicting_files=$( \
    comm -12 \
    <(echo "$untracked_files") \
    <(echo "$original_tracked_files") \
)
if [ -n "$untracked_conflicting_files" ]; then
    echo $untracked_conflicting_files | \
        xargs git stash push --include-untracked \
        --message "Untracked conflicting files"
    (( num_stash_entries += 1 ))
fi

# Switch to the original branch to update it
git switch $original_branch

if [ -n "$new_base_commit" ]; then
    git merge --no-commit $new_base_commit
fi

# Restore state of the repository without aborting the merge, if any
repo_root_directory=$(git rev-parse --show-toplevel)
git restore --staged --worktree $repo_root_directory

# Apply the diff and stage it
echo "$diff" | git apply --index -

# Commit changes
if [ -n "$commit_message" ]; then
    git commit -m "$commit_message"
else
    # Request the commit message from the user
    # Also show the user the diff with --verbose when writing the message
    git commit --verbose
fi

git switch $current_branch

# Restore stash
if (( $num_stash_entries > 0 )); then
    for i in $(seq 1 $num_stash_entries); do
        echo "Popping stash entry ($i/$num_stash_entries)"
        git stash pop 2>&1 > /dev/null
    done
fi

